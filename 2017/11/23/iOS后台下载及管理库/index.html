<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="iOS 后台下载及管理库 2017-11-23 LeavesLife Cocoa开发者社区 说起下载第一个想起的就是ASI。一年前接手的新项目是核心功能是视频相关业务，在修改和解决视频下载相关的问题的时候让我体会到了ASI的下载的强大。后来新需求需要视频后台下载，使用NSURLSession的时候，更加深刻的体会到了A">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS后台下载及管理库">
<meta property="og:url" content="http://yoursite.com/2017/11/23/iOS后台下载及管理库/index.html">
<meta property="og:site_name" content="Tec_张鲲">
<meta property="og:description" content="iOS 后台下载及管理库 2017-11-23 LeavesLife Cocoa开发者社区 说起下载第一个想起的就是ASI。一年前接手的新项目是核心功能是视频相关业务，在修改和解决视频下载相关的问题的时候让我体会到了ASI的下载的强大。后来新需求需要视频后台下载，使用NSURLSession的时候，更加深刻的体会到了ASI的强大好用。 后来替换下载的时候的原因： ASI开启后台下载功能，在iOS1">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-11-28T11:38:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS后台下载及管理库">
<meta name="twitter:description" content="iOS 后台下载及管理库 2017-11-23 LeavesLife Cocoa开发者社区 说起下载第一个想起的就是ASI。一年前接手的新项目是核心功能是视频相关业务，在修改和解决视频下载相关的问题的时候让我体会到了ASI的下载的强大。后来新需求需要视频后台下载，使用NSURLSession的时候，更加深刻的体会到了ASI的强大好用。 后来替换下载的时候的原因： ASI开启后台下载功能，在iOS1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/23/iOS后台下载及管理库/"/>





  <title>iOS后台下载及管理库 | Tec_张鲲</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tec_张鲲</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">IOS 技术整理</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/23/iOS后台下载及管理库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sadmile">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tec_张鲲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS后台下载及管理库</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T13:36:39+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>iOS 后台下载及管理库</p>
<p>2017-11-23 LeavesLife Cocoa开发者社区</p>
<p>说起下载第一个想起的就是ASI。一年前接手的新项目是核心功能是视频相关业务，在修改和解决视频下载相关的问题的时候让我体会到了ASI的下载的强大。后来新需求需要视频后台下载，使用NSURLSession的时候，更加深刻的体会到了ASI的强大好用。</p>
<p>后来替换下载的时候的原因：</p>
<p>ASI开启后台下载功能，在iOS10的设备上，只能下载三分钟，然后就处于休眠状态<br>AFN下载也是三分钟<br>测试后台下载的时候，不要用模拟器，使用用真机。模拟器APP处于后台时不会休眠。</p>
<a id="more"></a>
<p>NSURLSession的特点简介</p>
<p>通过NSURLSession创建的后台下载任务，保证了APP在后台或者退出的状态下，依然能进行下载任务，下载完成后通过唤醒APP，来将下载完成的数据保存到特定的位置。</p>
<p>在APP处于后台、锁屏状态下依然能后下载<br>最强大的是：APP在手动退出以及闪退后的状态下依然能够进行下载任务</p>
<p>NSURLSession</p>
<p>创建下载session</p>
<p>NSString <em>bundleId = [[[NSBundle mainBundle] infoDictionary] objectForKey:@”CFBundleIdentifier”];<br>NSString </em>identifier = [NSString stringWithFormat:@”%@.BackgroundSession”, bundleId];<br>NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:identifier];<br>session = [NSURLSession sessionWithConfiguration:sessionConfig<br>delegate:self<br>delegateQueue:[NSOperationQueue mainQueue]];</p>
<p>在创建下载session的时候，需要一个下载标识，该标识需要在整个个系统内保证唯一，所以使用APP的bundle id。<br>sessionConfig.allowsCellularAccess 控制是否可以通过蜂窝网络下载</p>
<p>当APP手动退出或者闪退后，重新启动时获取正在下载的tasks</p>
<p>NSMutableDictionary <em>dictM = [self.downloadSession valueForKey:@”tasks”];<br>[dictM enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL </em> _Nonnull stop) {</p>
<p>}];</p>
<p>AppDelegate后台下载回调</p>
<p>当APP处于后台下载状态时，需要处理下载完成后的数据的回调，这里就涉及了一个AppDelegate中的一个特别重要的回调</p>
<p>-(void)application:(UIApplication <em>)application handleEventsForBackgroundURLSession:(NSString </em>)identifier completionHandler:(void (^)(void))completionHandler{<br>NSLog(@”%s”, <strong>func</strong>);<br>}</p>
<p>该代理方法使用场景分析(详细分析过程见下面)：</p>
<p>不实现该代理方法，手动进入App调用相关代理方法，部分情况下异常<br>实现该方法，不执行completionHandler，某一下载任务完成后唤醒App，继续其它下载任务，异常<br>实现该方法，执行completionHandler，某一下载任务完成后唤醒App，继续其它下载任务，一切正常</p>
<p>相关操作</p>
<p>1.创建下载任务:其实通过session创建的任务是NSURLSessionDownloadTask的子类__NSCFBackgroundDownloadTask，是苹果的私有API。</p>
<p>NSURL <em>downloadURL = [NSURL URLWithString:downloadURLString];<br>NSURLRequest </em>request = [NSURLRequest requestWithURL:downloadURL];<br>NSURLSessionDownloadTask *downloadTask = [self.downloadSession downloadTaskWithRequest:request];<br>[downloadTask resume];</p>
<p>2.暂停下载:downloadTask有多种办法去暂停，但是我们选择有resume的下载方法，可以更加方便我们管理和多次暂停继续。</p>
<p>[downloadTask cancelByProducingResumeData:^(NSData * resumeData) {<br>}];</p>
<p>3.继续下载:通过resumeData继续下载。</p>
<p>NSURLSessionDownloadTask *downloadTask = [self.downloadSession downloadTaskWithResumeData:data];<br>[downloadTask resume];</p>
<p>4.取消或者删除下载</p>
<p>[downloadTask cancel];</p>
<p>相关代理方法说明</p>
<p>1.下载任务开始后，下载文件的进度回调方法。bytesWritten 某一断点续传过程中已经下载的数据大小， totalBytesWritten 已经下载的文件的大小；totalBytesExpectedToWrite当前需要下载的文件的大小</p>
<ul>
<li>(void)URLSession:(NSURLSession <em>)session<br>downloadTask:(NSURLSessionDownloadTask </em>)downloadTask<br>didWriteData:(int64_t)bytesWritten<br>totalBytesWritten:(int64_t)totalBytesWritten<br>totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{</li>
</ul>
<p>}</p>
<p>2.下载任务继续开始下载时的回调方法</p>
<ul>
<li>(void)URLSession:(NSURLSession <em>)session<br>downloadTask:(NSURLSessionDownloadTask </em>)downloadTask<br>didResumeAtOffset:(int64_t)fileOffset<br>expectedTotalBytes:(int64_t)expectedTotalBytes {</li>
</ul>
<p>}</p>
<p>3.当资源发生重定向时回调的方法。NSURLSession内部自己处理定向回调</p>
<ul>
<li>(void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task<br>willPerformHTTPRedirection:(NSHTTPURLResponse <em>)response<br>newRequest:(NSURLRequest </em>)request<br>completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler{</li>
</ul>
<p>}</p>
<p>讲个小故事：去年元旦左右，我们是使用ASI下载视频的，甘肃的一个用户反馈，视频死活不能下载。但是我们在公司网络，国外VPN，4G，家里的网络测试下载没有问题，并且进行n次的测试，没有复现该问题，后来只能只作罢。然后过年回家，腊月30到家的，和家人吃年夜饭过后，看春晚，实在没意思，突然想起这个问题，然后就测试代码，我去，还真的是个必现的bug，死活下载不了。卡断点，调试一会后，发现下载资源URL被302重定向了，然后我们项目中的以前集成ASI，并不支持重定向，最后在失败的回调用，判断了下，如果是重定向，拿到新的URL重新去下载，想想也是坑啊。 下载的资源经过cdn加速后，猜测cdn在不同的region做了不同的处理。然后北京没事，其它的地域有可能重定向了。当时改完代后有点小开心， 因为怕同事说我猿气太重，所以在公司提交的代码…</p>
<p>4.当下载任务完成后的代理回调方法，回调的参数location是下载完成后的文件，在沙盒当中存在的路径</p>
<ul>
<li>(void)URLSession:(NSURLSession <em>)session<br>downloadTask:(NSURLSessionDownloadTask </em>)downloadTask<br>didFinishDownloadingToURL:(NSURL *)location{</li>
</ul>
<p>}</p>
<p>5.假如在后台下载完成的回调，会触发该回调方法。</p>
<ul>
<li>(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{<br>}</li>
</ul>
<p>6.下载失败后的回调。暂停，停止，失败都会触发。区别是：正常状态下的暂停会回调resumeData，如果resumeData不为空的话我们需要保存该数据，方便下次继续。</p>
<ul>
<li>(void)URLSession:(NSURLSession <em>)session<br>task:(NSURLSessionTask </em>)task<br>didCompleteWithError:(NSError *)error{<br>}</li>
</ul>
<p>后台下载相关回调</p>
<p>AppDelegate 回调方法3种情况分析：</p>
<ol>
<li>不实现代理方法<br>当不实现AppDelegate代理方法的时候，简单的下载是没有任何问题。NSURLSession下载完成后相关代理方法执行顺序如图：</li>
</ol>
<p>代理调用顺序</p>
<p>只有手动将后台的App进入前台后会调用成功的回调，处理相关的数据。假如有3个下载任务则会回调3次URLSession:downloadTask:didFinishDownloadingToURL:方法。</p>
<p>缺点和问题：</p>
<p>如果下载完成后，不进入前台或者手动杀死进程，则丢失下载数据<br>等待下载的任务无法继续下载<br>下载完成后，在后台无法使用本地通知</p>
<ol>
<li>实现代理方法，不执行completionHandler</li>
</ol>
<p>AppDelegate 方法-(void)application:(UIApplication <em>)application handleEventsForBackgroundURLSession:(NSString </em>)identifier completionHandler:(void (^)(void))completionHandler completionHandler 作用：</p>
<p>首先看苹果SDK的解释：</p>
<p>// Applications using an NSURLSession with a background configuration may be launched or resumed in the background in order to handle the<br>// completion of tasks in that session, or to handle authentication. This method will be called with the identifier of the session needing<br>// attention. Once a session has been created from a configuration object with that identifier, the session’s delegate will begin receiving<br>// callbacks. If such a session has already been created (if the app is being resumed, for instance), then the delegate will start receiving<br>// callbacks without any action by the application. You should call the completionHandler as soon as you’re finished handling the callbacks.</p>
<p>最后两句是说明completionHandler的，大概意思是：回调callbacks，只要session创建将会开始接收到。回调callbacks没有对你的应用程序进行任何的处理，一旦完成处理callbacks，你应该调用completionHandler。</p>
<p>英语不好感觉说的云里雾里的。callbacks应该是暂停继续任务时受到的代理方法。说的是我们完成下载任务后应该调用completionHandler</p>
<p>completionHandler作用测试代理：</p>
<p>#pragma mark - test code</p>
<ul>
<li>(void)applicationWillResignActive:(UIApplication *)application{</li>
</ul>
<p>[self testTimer];<br>NSLog(@”%s”,<strong>func</strong>);<br>}</p>
<ul>
<li><p>(void)applicationDidBecomeActive:(UIApplication *)application {<br>[self.timer invalidate];<br>self.timer = nil;<br>self.duration = 0;<br>NSLog(@”%s”, <strong>func</strong>);<br>}</p>
</li>
<li><p>(void)testTimer {<br>self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerRun) userInfo:nil repeats:true];<br>[self.timer fire];<br>}</p>
</li>
<li><p>(void)timerRun {<br>_duration += 1;<br>NSLog(@”%zd”, _duration);<br>}</p>
</li>
</ul>
<p>completionHandler具体作用：</p>
<p>这个回调的作用有点牛皮。通过上面代理可以测试出completionHandler，在第一个后台下载任务完成时回调，这时后台App已经被唤醒，定时器开始输出计时秒数。然后其它的下载任务完成时不会再次回调该方法。所有下载任务完成时，没有处理completionHandler计时器继续运行。 调用执行时completionHandler计时器停止运行，App继续处于休眠状态。</p>
<p>虽然不知道completionHandler做了哪些处理，但是通过测试现象得出大概的作用。他用来控制后台的App被唤醒后继续处于休眠状态，节约系统资源。</p>
<p>所以不执行completionHandler App如果不重新启动，处于后台时会一直在运行状态。下载任务正常。</p>
<ol>
<li>实现代理方法，执行completionHandler</li>
</ol>
<p>上面我们分析了completionHandler大概作用。所以所有后台任务下载完成后调用completionHandler，是App处于正常的状态。相关代理调用顺序：</p>
<p>代理调用顺序</p>
<p>completionHandler调用时机：<br>所有的下载任务下载完成后调用。感兴趣的可以看YCDowloadSession下载库对completionHandler的处理逻辑。</p>
<p>YCDownloadSession</p>
<p>YCDownloadSession是我写的一个视频后台下载的库。里面拥有我对视频下载的详细的处理过程和管理的库。</p>
<p>该视频下载库主要有四个核心类：YCDownloadSession，YCDownloadTask，YCDownloadItem，YCDownloadManager</p>
<p>YCDownloadSession：对NSURLSession的进一步分装，是一个单例，所有的下载任务都是由其生成和管理。是最主要的核心类。实现了下载的代理方法，通过一个可下载的url，生成一个YCDownloadTask，并且将该task的所有数据进行实时存储。<br>YCDownloadTask 将YCDownloadSession里的代理方法进一步封装和扩展，保存session生成和所需要的一些下载信息和数据。<br>YCDownloadItem 存放需要下载的视频的信息<br>YCDownloadManager 管理下载视频操作，生成一个YCDownloadItem，并且实时保存相关信息(下载状态，文件大小，已下载文件大小，以及其它的需要和UI交互的数据)，然后调用YCDownloadSession去下载该视频。</p>
<p>图解</p>
<p>YCDownloadSession结构图解</p>
<p>YCDownloadSession和YCDownloadTask是两个核心类。与YCDownloadManager和YCDownloadItem相互独立。大家和可以通过YCDownloadSession和YCDownloadTask自定义需要的下载管理类的信息类。</p>
<p>使用效果图</p>
<p>单文件下载测试</p>
<p>单文件下载</p>
<p>多视频下载测试</p>
<p>多视频下载</p>
<p>通知</p>
<p>通知</p>
<p>用法</p>
<p>1.AppDelegate设置后台下载成功回调方法</p>
<p>-(void)application:(UIApplication <em>)application handleEventsForBackgroundURLSession:(NSString </em>)identifier completionHandler:(void (^)(void))completionHandler{<br>[[YCDownloadSession downloadSession] addCompletionHandler:completionHandler];<br>}</p>
<p>如果想要多个任务在后台同时进行，必须要进行设置上述的代理方法。YCDownloadSession内部会处理该回调方法(completionHandler的作用将会在blog里详细说明)，内部处理逻辑：</p>
<p>//等task delegate方法执行完成后去判断该逻辑<br>//URLSessionDidFinishEventsForBackgroundURLSession 方法在后台执行一次，所以在此判断执行completedHandler<br>if (status == YCDownloadStatusFinished) {</p>
<p>if ([self allTaskFinised]) {<br>[[NSNotificationCenter defaultCenter] postNotificationName:kDownloadAllTaskFinishedNoti object:nil];<br>//所有的任务执行结束之后调用completedHanlder<br>if (self.completedHandler) {<br>NSLog(@”completedHandler”);<br>self.completedHandler();<br>self.completedHandler = nil;<br>}<br>}</p>
<p>}</p>
<p>2.直接使用YCDownloadSession下载文件</p>
<p>self.downloadURL = @”<a href="http://dldir1.qq.com/qqfile/QQforMac/QQ_V6.0.1.dmg" target="_blank" rel="noopener">http://dldir1.qq.com/qqfile/QQforMac/QQ_V6.0.1.dmg</a>“;</p>
<ul>
<li>(void)start {<br>[[YCDownloadSession downloadSession] startDownloadWithUrl:self.downloadURL delegate:self saveName:nil];<br>}</li>
<li><p>(void)resume {<br>[[YCDownloadSession downloadSession] resumeDownloadWithUrl:self.downloadURL delegate:self saveName:nil];<br>}</p>
</li>
<li><p>(void)pause {<br>[[YCDownloadSession downloadSession] pauseDownloadWithUrl:self.downloadURL];<br>}</p>
</li>
<li><p>(void)stop {<br>[[YCDownloadSession downloadSession] stopDownloadWithUrl:self.downloadURL];<br>}</p>
</li>
</ul>
<p>//代理</p>
<ul>
<li>(void)downloadProgress:(YCDownloadTask <em>)task downloadedSize:(NSUInteger)downloadedSize fileSize:(NSUInteger)fileSize {<br>self.progressLbl.text = [NSString stringWithFormat:@”%f”,(float)downloadedSize / fileSize </em> 100];<br>}</li>
</ul>
<ul>
<li>(void)downloadStatusChanged:(YCDownloadStatus)status downloadTask:(YCDownloadTask *)task {<br>if (status == YCDownloadStatusFinished) {<br>self.progressLbl.text = @”download success!”;<br>}else if (status == YCDownloadStatusFailed){<br>self.progressLbl.text = @”download failed!”;<br>}<br>}</li>
</ul>
<p>3.使用自定义的管理类(YCDownloadManager 视频类型文件专用下载管理类)下载。假如视频下载完成，自定义保存名称，那么使用fileId来标识。如果fileId为空使用下载URL的MD5的值来保存</p>
<p>/**<br>开始/创建一个后台下载任务。downloadURLString作为整个下载任务的唯一标识。<br>下载成功后用downloadURLString的MD5的值来保存<br>文件后缀名取downloadURLString的后缀名，[downloadURLString pathExtension]</p>
<p>*/</p>
<ul>
<li>(void)startDownloadWithUrl:(NSString <em>)downloadURLString fileName:(NSString </em>)fileName imageUrl:(NSString *)imagUrl;</li>
</ul>
<p>/**<br>开始/创建一个后台下载任务。fileId作为整个下载任务的唯一标识。<br>下载成功后用fileId来保存, 要确保fileId唯一<br>文件后缀名取downloadURLString的后缀名，[downloadURLString pathExtension]</p>
<p>*/</p>
<ul>
<li>(void)startDownloadWithUrl:(NSString <em>)downloadURLString fileName:(NSString </em>)fileName imageUrl:(NSString <em>)imagUrl fileId:(NSString </em>)fileId;</li>
</ul>
<p>4.蜂窝煤是否允许下载的方法(YCDownloadSession, YCDownloadManager)</p>
<p>YCDownloadSession:<br>/**<br>是否允许蜂窝煤网络下载，以及网络状态变为蜂窝煤是否允许下载，必须把所有的downloadTask全部暂停，然后重新创建。否则，原先创建的<br>下载task依旧在网络切换为蜂窝煤网络时会继续下载</p>
<p>@param isAllow 是否允许蜂窝煤网络下载<br>*/</p>
<ul>
<li>(void)allowsCellularAccess:(BOOL)isAllow;</li>
</ul>
<p>YCDownloadManager:<br>/<em>*<br>获取当前是否允许蜂窝煤访问状态
</em>/</p>
<ul>
<li>(BOOL)isAllowsCellularAccess;</li>
</ul>
<p>5.设置最大同时进行下载的任务数</p>
<p>YCDownloadSession:<br>/<em>*<br>设置下载任务的个数，最多支持3个下载任务同时进行。<br>NSURLSession最多支持5个任务同时进行<br>但是5个任务，在某些情况下，部分任务会出现等待的状态，所有设置最多支持3个
</em>/<br>@property (nonatomic, assign) NSInteger maxTaskCount;</p>
<p>YCDownloadManager:<br>/<em>*<br>设置下载任务的个数，最多支持3个下载任务同时进行。
</em>/</p>
<ul>
<li>(void)setMaxTaskCount:(NSInteger)count;</li>
</ul>
<p>6.下载完成的通知</p>
<p>本地通知(YCDownloadManager实现)：</p>
<p>/<em>*<br>本地通知的开关，默认是false,可以根据通知名称自定义通知类型
</em>/</p>
<ul>
<li>(void)localPushOn:(BOOL)isOn;</li>
</ul>
<p>当前session中所有的任务下载完成的通知。 不包括失败、暂停的任务: kDownloadAllTaskFinishedNoti</p>
<p>某一的任务下载完成的通知object为YCDownloadItem对象：kDownloadTaskFinishedNoti</p>
<p>7.某一任务下载的状态发生变化的通知: kDownloadStatusChangedNoti 主要用于状态改变后，及时保存下载数据信息。</p>
<p>GitHub连接<br><a href="https://github.com/onezens/YCDownloadSession" target="_blank" rel="noopener">https://github.com/onezens/YCDownloadSession</a></p>
<p>欢迎各位关注该库，如果你有任何问题请issues我，将会随时更新新功能和解决存在的问题。</p>
<p>遇到的一些问题</p>
<p>这里总结下载开发YCDownloadSession下载库中碰到的一些问题</p>
<p>苹果下载相关SDK关系图</p>
<p>1.下载资源重定向的问题</p>
<p>YCDownloadSession 内部标识一下下载task的时候，使用的下载资源的URL来标识。如果该资源被301/302重定向到一个另一个URL后，会存在两个URL。标识用的URL在代理回调的NSURLSessionTask或者NSURLSessionDownloadTask的currentRequest中取的url，这样就出现了一个问题，重定向后通过URL拿不到下载的task；originalRequest属性可以拿到重定向前的URL使用该属性解决这个问题。苹果下载相关SDK关系图可看它们之间关系。</p>
<p>2.断点续传</p>
<p>NSURLSessionDownloadTask的断点续传是由其内部自己控制实现。在暂停某一下载任务的时候有两个方法：</p>
<p>cancel内部自己控制断点续传数据，拿到对应task可以继续下载。如果拿不到，不可继续。<br>cancelByProducingResumeData:^(NSData * resumeData) {}通过session继续下载[downloadSession downloadTaskWithResumeData:data]，需要自己保存处理resumeData，可以满足很多情况下的续传。</p>
<p>3.部分下载资源不可断点续传</p>
<p>YCDownloadSession Demo中的测试用的下载资源来自百度视频，可以正常下载。网易视频的资源和部分响应头不完整的资源在暂停下载之后拿不到resumeData而回调失败的情况。</p>
<p>百度视频资源：<a href="https://vd1.bdstatic.com/mda-hiqmm8s10vww26sx/mda-hiqmm8s10vww26sx.mp4\?playlist\=%5B%22hd%22%5D\&amp;auth_key\=1506158514-0-0-6cde713ec6e6a15bd856fbb4f2564658\&amp;bcevod_channel\=searchbox_feed" target="_blank" rel="noopener">https://vd1.bdstatic.com/mda-hiqmm8s10vww26sx/mda-hiqmm8s10vww26sx.mp4\?playlist\=%5B%22hd%22%5D\&amp;auth_key\=1506158514-0-0-6cde713ec6e6a15bd856fbb4f2564658\&amp;bcevod_channel\=searchbox_feed</a></p>
<p>响应头：</p>
<p>通过Mac Terminal自带的curl命令获取响应头 curl -I <a href="https://vd1.bdstatic.com/mda-hiqmm8s10vww26sx/mda-hiqmm8s10vww26sx.mp4\?playlist\=%5B%22hd%22%5D\&amp;auth_key\=1506158514-0-0-6cde713ec6e6a15bd856fbb4f2564658\&amp;bcevod_channel\=searchbox_feed" target="_blank" rel="noopener">https://vd1.bdstatic.com/mda-hiqmm8s10vww26sx/mda-hiqmm8s10vww26sx.mp4\?playlist\=%5B%22hd%22%5D\&amp;auth_key\=1506158514-0-0-6cde713ec6e6a15bd856fbb4f2564658\&amp;bcevod_channel\=searchbox_feed</a></p>
<p>HTTP/1.1 200 OK<br>Server: bfe/1.0.8.13-sslpool-patch<br>Date: Tue, 10 Oct 2017 07:43:02 GMT<br>Content-Type: video/mp4<br>Content-Length: 19727666<br>Connection: keep-alive<br>ETag: “125b8b749037921ccd03120fb0f90189”<br>Last-Modified: Fri, 15 Sep 2017 09:42:18 GMT<br>Accept-Ranges: bytes<br>Content-MD5: EluLdJA3khzNAxIPsPkBiQ==<br>x-bce-debug-id: MTAuMTgxLjk5LjE0OlNhdCwgMTYgU2VwIDIwMTcgMTE6MzA6MzYgQ1NUOjE4MzY0NTgzMjM=<br>x-bce-request-id: b3c7857b-b71a-4cd4-ab98-8676319dc8cb<br>x-bce-storage-class: STANDARD<br>Ohc-Response-Time: 1 0 0 0 0 94<br>Access-Control-Allow-Origin: *<br>Cache-Control: max-age=2592000</p>
<p>网易视频资源：<a href="http://flv2.bn.netease.com/videolib3/1706/07/gDNOH8458/HD/gDNOH8458-mobile.mp4" target="_blank" rel="noopener">http://flv2.bn.netease.com/videolib3/1706/07/gDNOH8458/HD/gDNOH8458-mobile.mp4</a></p>
<p>响应头：</p>
<p>curl -I <a href="http://flv2.bn.netease.com/videolib3/1706/07/gDNOH8458/HD/gDNOH8458-mobile.mp4" target="_blank" rel="noopener">http://flv2.bn.netease.com/videolib3/1706/07/gDNOH8458/HD/gDNOH8458-mobile.mp4</a></p>
<p>HTTP/1.1 200 OK<br>Expires: Thu, 09 Nov 2017 07:00:42 GMT<br>Date: Tue, 10 Oct 2017 07:00:42 GMT<br>Server: nginx<br>Content-Length: 43260722<br>Cache-Control: max-age=2592000<br>Content-Type: video/mp4<br>Via: 1.1 zhshx117:1 (Cdn Cache Server V2.0)[11 200 2], 1.1 xxz195:3 (Cdn Cache Server V2.0)[94 200 2], 1.1 PStjdgdx3jx152:4 (Cdn Cache Server V2.0)[154 200 2]<br>Connection: keep-alive<br>cache: state<br>cdn-user-ip: 101.96.129.122<br>cdn-ip: 42.81.28.152<br>cdn-source: chinanetcenter</p>
<p>响应头异常视频资源：<a href="https://www.zmzfile.com:9043/rt/route\?fileid\=152260954bdfa322725ba58df2ab1e2c2e3a6050" target="_blank" rel="noopener">https://www.zmzfile.com:9043/rt/route\?fileid\=152260954bdfa322725ba58df2ab1e2c2e3a6050</a></p>
<p>响应头：</p>
<p>curl -I <a href="https://www.zmzfile.com:9043/rt/route\?fileid\=152260954bdfa322725ba58df2ab1e2c2e3a6050" target="_blank" rel="noopener">https://www.zmzfile.com:9043/rt/route\?fileid\=152260954bdfa322725ba58df2ab1e2c2e3a6050</a></p>
<p>HTTP/1.1 302 Found<br>Server: nginx/1.12.1<br>Date: Tue, 10 Oct 2017 07:53:23 GMT<br>Content-Type: text/plain; charset=utf-8<br>Connection: keep-alive<br>Location: <a href="http://175.6.228.3:9021?id=152260954bdfa322725ba58df2ab1e2c2e3a6050" target="_blank" rel="noopener">http://175.6.228.3:9021?id=152260954bdfa322725ba58df2ab1e2c2e3a6050</a><br>Ts: 1716489</p>
<p>继续取302资源的响应头<br>curl -I <a href="http://175.6.228.3:9021\?id\=152260954bdfa322725ba58df2ab1e2c2e3a6050" target="_blank" rel="noopener">http://175.6.228.3:9021\?id\=152260954bdfa322725ba58df2ab1e2c2e3a6050</a><br>Ts: 1716489<br>curl: (52) Empty reply from server</p>
<p>Xcode 输出NSURLSessionDownloadTask的response信息：</p>
<p><nshttpurlresponse: 0x13cee64d0=""> { URL: <a href="http://60.211.203.204:9031/?id=152260954bdfa322725ba58df2ab1e2c2e3a6050" target="_blank" rel="noopener">http://60.211.203.204:9031?id=152260954bdfa322725ba58df2ab1e2c2e3a6050</a> } {<br>status code: 200,<br>headers {<br>Connection = Close;<br>“Content-Length” = 247272762;<br>Server = p4pcacher;<br>} }</nshttpurlresponse:></p>
<p>目前这个问题还正在探索解决的办法中。目前来看断点续传是系统内部实现的，苹果SDK没有提供一些相关的操作，如果出现类似的问题，那么只能和后台沟通，解决响应头相关的信息来解决这个问题。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/23/Hexo免费搭建一个属于自己的博客/" rel="next" title="Hexo免费搭建一个属于自己的博客">
                <i class="fa fa-chevron-left"></i> Hexo免费搭建一个属于自己的博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/23/iOS-贝塞尔曲线之自定义饼图/" rel="prev" title="iOS-贝塞尔曲线之自定义饼图">
                iOS-贝塞尔曲线之自定义饼图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sadmile</p>
              <p class="site-description motion-element" itemprop="description">日常开发调研、收藏整理的技术栈</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sadmile</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
